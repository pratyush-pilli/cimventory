import "./requisition.scss";
import "../../styles/responsive.scss";
import React, { useState, useEffect } from "react";
import * as XLSX from "xlsx";
import {
  DataGrid,
  GridRowsProp,
  GridRowModesModel,
  GridRowModes,
  GridColDef,
  GridActionsCellItem,
  GridRowId,
  GridRowModel,
  GridRowEditStopReasons,
} from "@mui/x-data-grid";
import {
  Button,
  TextField,
  Grid,
  Autocomplete,
  Paper,
  Typography,
  Box,
  useTheme,
  useMediaQuery,
} from "@mui/material";
import axios from "axios";
import EditIcon from "@mui/icons-material/Edit";
import SaveIcon from "@mui/icons-material/Save";
import CancelIcon from "@mui/icons-material/Close";
import DeleteIcon from "@mui/icons-material/Delete";
import { format } from "date-fns";

const RequisitionForm: React.FC = () => {
  const [rows, setRows] = useState<GridRowsProp>([]);
  const [rowModesModel, setRowModesModel] = useState<GridRowModesModel>({});
  const [filters, setFilters] = useState({
    client_project_name: "",
    project_code: "",
    approved_by: "",
    requested_by: "",
    submitted_by: "",
  });
  const [filteredRows, setFilteredRows] = useState<GridRowsProp>([]);
  const [filterOptions, setFilterOptions] = useState<{
    [key: string]: string[];
  }>({});
  const [commonFields, setCommonFields] = useState({
    approved_by: "",
    requested_by: "",
    submitted_by: "",
  });

  const theme = useTheme();
  const isSmallScreen = useMediaQuery(theme.breakpoints.down("sm"));

  useEffect(() => {
    fetchData();
  }, []);

  useEffect(() => {
    applyFilters();
  }, [filters, rows]);

  const fetchData = () => {
    axios
      .get("http://localhost:8000/requisitions/")
      .then((response) => {
        const dataWithId = response.data.map((item: any) => ({
          ...item,
          id: item.id,
          requisition_date: new Date(item.requisition_date),
          required_by_date: item.required_by_date
            ? new Date(item.required_by_date)
            : null,
        }));
        setRows(dataWithId);
        setFilteredRows(dataWithId);
        // Set common fields based on the first row
        if (dataWithId.length > 0) {
          setCommonFields({
            approved_by: dataWithId[0].approved_by,
            requested_by: dataWithId[0].requested_by,
            submitted_by: dataWithId[0].submitted_by,
          });
        }
      })
      .catch((error) => {
        console.error("Error fetching data:", error);
      });
  };

  const handleFilterChange = (event: React.ChangeEvent<HTMLInputElement>) => {
    const { name, value } = event.target;
    setFilters((prevFilters) => ({
      ...prevFilters,
      [name]: value,
    }));
  };

  const applyFilters = () => {
    let filtered = [...rows];
    Object.keys(filters).forEach((key) => {
      if (
        filters[key as keyof typeof filters] &&
        filters[key as keyof typeof filters] !== "All"
      ) {
        const filterValues = filters[key as keyof typeof filters]
          .split(",")
          .map((value) => value.trim().toLowerCase());
        filtered = filtered.filter((item) =>
          filterValues.some((filterValue) =>
            String(item[key as keyof typeof item])
              .toLowerCase()
              .includes(filterValue)
          )
        );
      }
    });
    setFilteredRows(filtered);
    updateFilterOptions(filtered);
  };

  const updateFilterOptions = (filteredData: any[]) => {
    const options: { [key: string]: string[] } = {};
    Object.keys(filters).forEach((key) => {
      options[key] = Array.from(
        new Set(
          filteredData
            .map((item) => String(item[key]))
            .filter((value) => value !== undefined)
        )
      ).sort();
    });
    setFilterOptions(options);
  };

  const processRowUpdate = (newRow: GridRowModel) => {
    setRows((prevRows) =>
      prevRows.map((row) => (row.id === newRow.id ? { ...newRow } : row))
    );
    return newRow;
  };

  const handleSaveClick = (id: GridRowId) => async () => {
    const row = rows.find((row) => row.id === id);
    if (!row) return;

    const formattedRow = {
      ...row,
      requisition_date: format(new Date(row.requisition_date), "yyyy-MM-dd"),
      required_by_date: row.required_by_date
        ? format(new Date(row.required_by_date), "yyyy-MM-dd")
        : null,
    };

    const url = id
      ? `http://localhost:8000/requisitions/${id}/`
      : "http://localhost:8000/requisitions/";
    const method = id ? "put" : "post";

    try {
      await axios[method](url, formattedRow);
      setRowModesModel({
        ...rowModesModel,
        [id]: { mode: GridRowModes.View },
      });
      alert("Requisition saved successfully!");
    } catch (error) {
      alert("Error saving data.");
    }
  };

  const handleEditClick = (id: GridRowId) => () => {
    setRowModesModel({ ...rowModesModel, [id]: { mode: GridRowModes.Edit } });
  };

  const handleDeleteClick = (id: GridRowId) => async () => {
    try {
      await axios.delete(`http://localhost:8000/requisitions/delete/${id}/`);
      setRows((prevRows) => prevRows.filter((row) => row.id !== id));
      alert("Requisition deleted successfully!");
    } catch (error) {
      console.error("Error deleting row:", error);
    }
  };

  const handleCancelClick = (id: GridRowId) => () => {
    setRowModesModel({
      ...rowModesModel,
      [id]: { mode: GridRowModes.View, ignoreModifications: true },
    });
  };

  const exportToExcel = () => {
    const worksheet = XLSX.utils.json_to_sheet(filteredRows as any);
    const workbook = XLSX.utils.book_new();
    XLSX.utils.book_append_sheet(workbook, worksheet, "Requisition Data");
    XLSX.writeFile(workbook, "requisition_data.xlsx");
  };

  const columns: GridColDef[] = [
    {
      field: "requisition_date",
      headerName: "Requisition Date",
      width: 150,
      type: "date",
      editable: true,
    },
    { field: "item_no", headerName: "Item No", width: 90, editable: true },
    {
      field: "cimcon_part_number",
      headerName: "CIMCON Part Number",
      width: 150,
      editable: true,
    },
    {
      field: "mfg_part_number",
      headerName: "MFG Part Number",
      width: 150,
      editable: true,
    },
    {
      field: "material_description",
      headerName: "Material Description",
      width: 200,
      editable: true,
    },
    { field: "make", headerName: "Make", width: 120, editable: true },
    {
      field: "material_group",
      headerName: "Material Group",
      width: 130,
      editable: true,
    },
    {
      field: "req_qty",
      headerName: "Required Quantity",
      width: 120,
      editable: true,
    },
    { field: "unit", headerName: "Unit", width: 90, editable: true },
    {
      field: "required_by_date",
      headerName: "Required By Date",
      width: 150,
      type: "date",
      editable: true,
    },
    { field: "remarks", headerName: "Remarks", width: 200, editable: true },
    {
      field: "actions",
      headerName: "Actions",
      width: 150,
      type: "actions",
      getActions: ({ id }) => {
        const isInEditMode = rowModesModel[id]?.mode === GridRowModes.Edit;
        if (isInEditMode) {
          return [
            <GridActionsCellItem
              icon={<SaveIcon />}
              label="Save"
              onClick={handleSaveClick(id)}
            />,
            <GridActionsCellItem
              icon={<CancelIcon />}
              label="Cancel"
              onClick={handleCancelClick(id)}
            />,
          ];
        }
        return [
          <GridActionsCellItem
            icon={<EditIcon />}
            label="Edit"
            onClick={handleEditClick(id)}
          />,
          <GridActionsCellItem
            icon={<DeleteIcon />}
            label="Delete"
            onClick={handleDeleteClick(id)}
          />,
        ];
      },
    },
  ];

  return (
    <Box className="requisition-container">
      <Paper className="requisition-paper" elevation={3}>
        <Typography variant="h4" component="h1" align="center" gutterBottom>
          Requisition Form
        </Typography>
        <Grid container spacing={3} className="requisition-grid">
          {/* <Grid item xs={12} sm={6} md={4}>
            <TextField
              label="Approved By"
              value={commonFields.approved_by}
              onChange={(e) =>
                setCommonFields({
                  ...commonFields,
                  approved_by: e.target.value,
                })
              }
              variant="outlined"
              fullWidth
            />
          </Grid>
          <Grid item xs={12} sm={6} md={4}>
            <TextField
              label="Requested By"
              value={commonFields.requested_by}
              onChange={(e) =>
                setCommonFields({
                  ...commonFields,
                  requested_by: e.target.value,
                })
              }
              variant="outlined"
              fullWidth
            />
          </Grid>
          <Grid item xs={12} sm={6} md={4}>
            <TextField
              label="Submitted By"
              value={commonFields.submitted_by}
              onChange={(e) =>
                setCommonFields({
                  ...commonFields,
                  submitted_by: e.target.value,
                })
              }
              variant="outlined"
              fullWidth
            />
          </Grid> */}
          {Object.keys(filters).map((key) => (
            <Grid item xs={12} sm={6} md={4} key={key}>
              <Autocomplete
                multiple
                options={filterOptions[key] || []}
                onChange={(_, value) =>
                  setFilters((prev) => ({ ...prev, [key]: value.join(",") }))
                }
                renderInput={(params) => (
                  <TextField {...params} label={key} variant="outlined" />
                )}
              />
            </Grid>
          ))}
        </Grid>
        <Box my={3} textAlign="center">
          <Button
            variant="contained"
            color="primary"
            onClick={exportToExcel}
            className="export-button"
          >
            Export to Excel
          </Button>
        </Box>
        <Box height={400} className="data-grid-container">
          <DataGrid
            rows={filteredRows}
            columns={columns}
            pageSize={isSmallScreen ? 5 : 10}
            editMode="row"
            rowModesModel={rowModesModel}
            onRowModesModelChange={(newModel) => setRowModesModel(newModel)}
            onRowEditStop={(params, event) => {
              if (params.reason === GridRowEditStopReasons.cellFocusOut) {
                event.defaultMuiPrevented = true;
              }
            }}
            processRowUpdate={processRowUpdate}
            experimentalFeatures={{ newEditingApi: true }}
          />
        </Box>
      </Paper>
    </Box>
  );
};

export default RequisitionForm;
